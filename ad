import tkinter as tk
from tkinter import filedialog, messagebox
import pandas as pd
import numpy as np
import os
import gc

def load_cdr_file(cdr_file_path):
    # Load only the needed columns from the CDR file, rename columns accordingly
    usecols = [0, 9, 25, 24, 21, 5, 2]  # Columns A, J, Z, Y, V, F, C
    column_names = ['CDRID', 'Client_arrangement_short_name', 'Highest_available_display_name', 'LEI', 'Entity', 'Entity_ID', 'Fund']
    cdr_df = pd.read_csv(cdr_file_path, sep='|', encoding='ISO-8859-1', header=None, usecols=usecols)
    cdr_df.columns = column_names
    cdr_df.set_index('Client_arrangement_short_name', inplace=True)  # Set as the index for matching with GBL_BKID in feed file
    return cdr_df

def process_single_feed_file(feed_file, cdr_df, output_file, close_value, merged_dir, output_columns):
    chunk_size = 2000
    first_chunk = True
    merged_output_path = os.path.join(merged_dir, f"merged_{os.path.basename(feed_file)}")

    for feed_chunk in pd.read_csv(feed_file, encoding='ISO-8859-1', chunksize=chunk_size):
        # Set GBL_BKID as the index for matching with CDR
        feed_chunk.set_index('GBL_BKID', inplace=True)  

        # Merge chunk with CDR data based on GBL_BKID
        merged_df = feed_chunk.join(cdr_df, how='left', rsuffix='_cdr')

        # Save a copy of the merged DataFrame to the specified merged directory
        merged_df.to_csv(merged_output_path, mode='a', index=True, header=first_chunk)
        
        # Convert large, repeated text columns to categorical to save memory
        merged_df['Product'] = 'Equity Derivatives'
        merged_df['Product'] = merged_df['Product'].astype('category')
        
        # Check if 'AM' column exists before using it
        if 'AM' in merged_df.columns:
            merged_df['EQD_SEC_FLAG'] = merged_df['AM'] == 'Y'
            merged_df['EQD_SEC_FLAG'] = merged_df['EQD_SEC_FLAG'].astype('category')
        else:
            merged_df['EQD_SEC_FLAG'] = False  # Default value if 'AM' does not exist
        
        # Use numpy for vectorized calculations
        merged_df['Units'] = -np.asarray(merged_df['M'], dtype=np.float32)
        merged_df['MTM (Local CCY)'] = (
            np.asarray(merged_df['Y'], dtype=np.float32) * 
            np.asarray(merged_df['Z'], dtype=np.float32) * 
            np.asarray(merged_df['AE'], dtype=np.float32)
        )
        merged_df['Close'] = close_value

        # Define the output DataFrame with the custom columns
        output_df = merged_df[output_columns].copy()
        
        # Write output DataFrame to the final output file
        output_df.to_csv(output_file, mode='a', index=False, header=first_chunk)
        first_chunk = False  # After the first write, subsequent chunks will not write the header

        # Explicitly delete processed data and run garbage collection
        del feed_chunk, merged_df, output_df
        gc.collect()

class DataProcessorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Data Processor")
        
        # File paths
        self.feed_files = [None, None, None]
        self.cdr_file = None
        self.output_file = None
        self.merged_dir = None
        self.output_columns = [
            'Sent_Status', 'Sent', 'Error', 'Product', 'Name', 'LEI', 'AppandShortName', 'CDR_Application',
            'Short_name', 'Entity', 'Entity_ID', 'CDRID', 'EQD_Client', 'Trade_ID', 'RBC_ID', 'RBC_Name', 
            'RBC_shortname', 'Fund', 'Trade_date', 'Maturity_Date', 'Sub_Product', 'EQD_DF_FLAG', 'EQD_SEC_FLAG',
            'Underlying', 'Units', 'Contract_size', 'Call_put', 'CCY', 'Long_Short', 'Adjustment', 
            'Unit_Price_Local_CCY', 'COB', 'Close', 'MTM_Local_CCY', 'MTM_USD', 'Strategy', 'Load_Type'
        ]
        
        # UI Setup
        tk.Label(root, text="Select Feed File 1").grid(row=0, column=0, padx=10, pady=5)
        self.feed1_btn = tk.Button(root, text="Browse", command=lambda: self.select_file(0))
        self.feed1_btn.grid(row=0, column=1, padx=10, pady=5)
        
        tk.Label(root, text="Select Feed File 2").grid(row=1, column=0, padx=10, pady=5)
        self.feed2_btn = tk.Button(root, text="Browse", command=lambda: self.select_file(1))
        self.feed2_btn.grid(row=1, column=1, padx=10, pady=5)
        
        tk.Label(root, text="Select Feed File 3").grid(row=2, column=0, padx=10, pady=5)
        self.feed3_btn = tk.Button(root, text="Browse", command=lambda: self.select_file(2))
        self.feed3_btn.grid(row=2, column=1, padx=10, pady=5)
        
        tk.Label(root, text="Select CDR File").grid(row=3, column=0, padx=10, pady=5)
        self.cdr_btn = tk.Button(root, text="Browse", command=self.select_cdr_file)
        self.cdr_btn.grid(row=3, column=1, padx=10, pady=5)
        
        tk.Label(root, text="Save Output As").grid(row=4, column=0, padx=10, pady=5)
        self.output_btn = tk.Button(root, text="Browse", command=self.select_output_file)
        self.output_btn.grid(row=4, column=1, padx=10, pady=5)

        tk.Label(root, text="Save Merged Files To").grid(row=5, column=0, padx=10, pady=5)
        self.merged_btn = tk.Button(root, text="Browse", command=self.select_merged_dir)
        self.merged_btn.grid(row=5, column=1, padx=10, pady=5)
        
        # Process Button
        self.process_btn = tk.Button(root, text="Process Files", command=self.process_files)
        self.process_btn.grid(row=6, column=0, columnspan=2, pady=20)
    
    def select_file(self, idx):
        file_path = filedialog.askopenfilename(filetypes=[("CSV Files", "*.csv")])
        if file_path:
            self.feed_files[idx] = file_path
            tk.Label(self.root, text=os.path.basename(file_path)).grid(row=idx, column=2)
    
    def select_cdr_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("PSV Files", "*.psv")])
        if file_path:
            self.cdr_file = file_path
            tk.Label(self.root, text=os.path.basename(file_path)).grid(row=3, column=2)
    
    def select_output_file(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV Files", "*.csv")])
        if file_path:
            self.output_file = file_path
            tk.Label(self.root, text=os.path.basename(file_path)).grid(row=4, column=2)

    def select_merged_dir(self):
        directory = filedialog.askdirectory()
        if directory:
            self.merged_dir = directory
            tk.Label(self.root, text=os.path.basename(directory)).grid(row=5, column=2)

    def process_files(self):
        if not all(self.feed_files) or not self.cdr_file or not self.output_file or not self.merged_dir:
            messagebox.showerror("Error", "Please select all feed files, CDR file, output file, and merged directory.")
            return
        
        try:
            # Load CDR file once and use it for all feed files
            cdr_df = load_cdr_file(self.cdr_file)

            # Process each feed file in chunks and append to output file
            for i, feed_file in enumerate(self.feed_files, start=1):
                process_single_feed_file(feed_file, cdr_df, self.output_file, i, self.merged_dir, self.output_columns)
            
            messagebox.showinfo("Success", f"Combined data saved to {self.output_file}")
        
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

# Run the application
if __name__ == '__main__':
    root = tk.Tk()
    app = DataProcessorApp(root)
    root.mainloop()
